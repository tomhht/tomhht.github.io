<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tomhht.github.io</id>
    <title>hello, world</title>
    <updated>2020-08-31T12:12:00.314Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tomhht.github.io"/>
    <link rel="self" href="https://tomhht.github.io/atom.xml"/>
    <logo>https://tomhht.github.io/images/avatar.png</logo>
    <icon>https://tomhht.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, hello, world</rights>
    <entry>
        <title type="html"><![CDATA[Ubuntu和CentOS端口设置]]></title>
        <id>https://tomhht.github.io/post/ubuntu-he-centos-duan-kou-she-zhi/</id>
        <link href="https://tomhht.github.io/post/ubuntu-he-centos-duan-kou-she-zhi/">
        </link>
        <updated>2020-08-31T09:53:59.000Z</updated>
        <summary type="html"><![CDATA[<p>记录下端口设置，用到啥记录啥。</p>
]]></summary>
        <content type="html"><![CDATA[<p>记录下端口设置，用到啥记录啥。</p>
<!-- more -->
<h1 id="centos">CentOS</h1>
<p>核心指令<code>firewall-cmd</code></p>
<h2 id="查看已开放端口">查看已开放端口</h2>
<pre><code>sudo firewall-cmd --list-ports
</code></pre>
<h2 id="开启端口">开启端口</h2>
<pre><code>sudo firewall-cmd --zone=public --add-port=10250/tcp --permanent
sudo firewall-cmd --zone=public --add-port=30000-32767/tcp --permanent
//--zone: 作用域 
//--add-port=2181/tcp: 要开启的端口号，格式为：端口号/通讯协议 
//--permanent: 使端口永久开放，如不添加，则表示临时有效，开机重启后便会失效
//30000-32767，端口区间
</code></pre>
<h2 id="关闭端口">关闭端口</h2>
<pre><code>sudo firewall-cmd --zone= public --remove-port=6443/tcp --permanent
</code></pre>
<h2 id="reload以便-permanent配置生效">reload以便--permanent配置生效</h2>
<pre><code>sudo firewall-cmd --reload
</code></pre>
<h1 id="ubuntu">Ubuntu</h1>
<p>核心指令<code>ufw</code></p>
<hr>
<p>参考链接：<br>
<a href="https://www.cnblogs.com/Sungeek/p/8257681.html">https://www.cnblogs.com/Sungeek/p/8257681.html</a><br>
<a href="https://blog.csdn.net/Sun_Hui_/article/details/103178840">https://blog.csdn.net/Sun_Hui_/article/details/103178840</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu和CentOS修改grub]]></title>
        <id>https://tomhht.github.io/post/ubuntu-he-centos-xiu-gai-grub/</id>
        <link href="https://tomhht.github.io/post/ubuntu-he-centos-xiu-gai-grub/">
        </link>
        <updated>2020-08-31T03:19:33.000Z</updated>
        <summary type="html"><![CDATA[<p>grub的修改位置和生效方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>grub的修改位置和生效方法。</p>
<!-- more -->
<p>grub的修改位置是同样的。</p>
<pre><code>sudo vim /etc/default/grub
</code></pre>
<p>生效方法有区别：</p>
<pre><code>sudo grub2-mkconfig –o /etc/grub2.cfg  #CentOS
sudo update-grub2  #Ubuntu
</code></pre>
<hr>
<p>参考链接：<br>
<a href="https://blog.csdn.net/whatday/article/details/106123164">https://blog.csdn.net/whatday/article/details/106123164</a><br>
<a href="https://www.techbrown.com/change-default-grub2-entries-timeout-centos-7/">https://www.techbrown.com/change-default-grub2-entries-timeout-centos-7/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在Ubuntu 20.04上使用kubeadm部署Kubernetes集群]]></title>
        <id>https://tomhht.github.io/post/zai-ubuntu-2004-shang-shi-yong-kubeadm-bu-shu-kubernetes-ji-qun/</id>
        <link href="https://tomhht.github.io/post/zai-ubuntu-2004-shang-shi-yong-kubeadm-bu-shu-kubernetes-ji-qun/">
        </link>
        <updated>2020-08-27T10:40:02.000Z</updated>
        <summary type="html"><![CDATA[<p>本文主要是踩坑后想记录下避坑方法，内容涉及Kubernetes, Kubeadm, Kubectl, Kubelet, Ubuntu, CentOS, Flannel, Docker, 阿里云。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文主要是踩坑后想记录下避坑方法，内容涉及Kubernetes, Kubeadm, Kubectl, Kubelet, Ubuntu, CentOS, Flannel, Docker, 阿里云。</p>
<!-- more -->
<h1 id="写作背景">写作背景</h1>
<p>初学Kubernetes，虽然网上资源很多，但没一个能彻底搞定，于是杂烩一下。</p>
<h1 id="安装前的准备工作">安装前的准备工作</h1>
<blockquote>
<p>control node（控制节点）、worker node（工作节点） 都要做这些准备工作。</p>
</blockquote>
<h2 id="创建k8s文件夹">创建k8s文件夹</h2>
<p>存放安装过程所需文件。执行下面代码：</p>
<pre><code>mkdir ~/k8s
</code></pre>
<h2 id="设置iptables">设置iptables</h2>
<p>执行下面代码：</p>
<pre><code>cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sudo sysctl --system
# 如果想检查配置，可执行
sysctl -n net.bridge.bridge-nf-call-iptables
sysctl -n net.bridge.bridge-nf-call-ip6tables
</code></pre>
<h2 id="打开端口">打开端口</h2>
<p>先打开Ubuntu自带的防火墙ufw，因为ufw设置似乎更简单一些。执行下面代码：</p>
<pre><code>sudo ufw enable
</code></pre>
<p>执行后提示可能断开连接，直接y继续，别担心，ssh连接不会断。<br>
如果使用ssh连接，还需要执行下面代码，以便打开ssh连接：</p>
<pre><code>sudo ufw allow ssh
</code></pre>
<p>接下来分别设置：</p>
<ol>
<li>控制节点 Control-plane nodes</li>
</ol>
<pre><code>sudo ufw allow 6443/tcp
sudo ufw allow 2379:2380/tcp
sudo ufw allow 10250:10252/tcp
</code></pre>
<p>上面代码中的冒号代表端口区间，如10250:10252代表10250、10251、10252这3个端口一起设置。<br>
2. 工作节点 Worker nodes</p>
<pre><code>sudo ufw allow 10250/tcp
sudo ufw allow 30000:32767/tcp
</code></pre>
<h2 id="禁用swap">禁用swap</h2>
<p>由于swap性能低下，Kubeadm默认要求禁止使用swap。执行如下代码：</p>
<pre><code>sudo swapoff -a  #临时禁用swap
sudo sed -i 's/.*swap.*/#&amp;/' /etc/fstab  #永久禁用swap
</code></pre>
<p>可通过<code>free -m</code>来检查禁用效果。</p>
<h1 id="安装kubeadm-kubelet和kubectl">安装kubeadm, kubelet和kubectl</h1>
<blockquote>
<p>control node（控制节点）、worker node（工作节点） 上都安装。<br>
<strong>Ubuntu代码</strong></p>
</blockquote>
<pre><code>sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl
curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -
cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list
deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main
EOF
sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
</code></pre>
<p><strong>CentOS代码</strong></p>
<pre><code>cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=0
repo_gpgcheck=0
gpgkey=https:/mirrors.aliyun.com/yum/doc/yum-key.gpg https://mirrors.aliyun.com/yum/doc/rpm-package-key.gpg
exclude=kubelet kubeadm kubectl
EOF

# Set SELinux in permissive mode (effectively disabling it)
sudo setenforce 0
sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config

sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes

sudo systemctl enable --now kubelet
</code></pre>
<h1 id="在control-node控制节点上用kubeadm创建集群">在control node控制节点上用kubeadm创建集群</h1>
<p>由于种种原因，国内无法从k8s.gcr.io下载到kubeadm部署所需的文件，以下方法将通过阿里云获取。</p>
<h2 id="准备工作">准备工作</h2>
<h3 id="查看所需镜像">查看所需镜像</h3>
<pre><code>kubeadm config images list
#下面是执行的结果
k8s.gcr.io/kube-apiserver:v1.18.8
k8s.gcr.io/kube-controller-manager:v1.18.8
k8s.gcr.io/kube-scheduler:v1.18.8
k8s.gcr.io/kube-proxy:v1.18.8
k8s.gcr.io/pause:3.2
k8s.gcr.io/etcd:3.4.3-0
k8s.gcr.io/coredns:1.6.7
</code></pre>
<h3 id="在阿里云控制台找到所需镜像">在阿里云控制台找到所需镜像</h3>
<ol>
<li>https://cr.console.aliyun.com/  左侧点”镜像搜索“</li>
<li>分别搜索”kube-apiserver“等所需镜像，点开搜索到的镜像，一定找到正确的版本号（如v1.18.8）（日期越新的越容易找到），复制页面中的”公网地址“</li>
</ol>
<h3 id="pull镜像-打标签-移除无用镜像">pull镜像、打标签、移除无用镜像</h3>
<ol>
<li>pull镜像</li>
</ol>
<pre><code>KUBE_VERSION=v1.18.8
PAUSE_VERSION=3.2
ETCD_VERSION=3.4.3-0
CORE_DNS_VERSION=1.6.7
docker pull registry.cn-hangzhou.aliyuncs.com/wyc_google_containers/kube-apiserver:$KUBE_VERSION
docker pull registry.cn-hangzhou.aliyuncs.com/wyc_google_containers/kube-controller-manager:$KUBE_VERSION
docker pull registry.cn-hangzhou.aliyuncs.com/wyc_google_containers/kube-scheduler:$KUBE_VERSION
docker pull registry.cn-hangzhou.aliyuncs.com/wyc_google_containers/kube-proxy:$KUBE_VERSION
docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/pause:$PAUSE_VERSION
docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:$CORE_DNS_VERSION
docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:$ETCD_VERSION
</code></pre>
<ol start="2">
<li>给pull下来的镜像打标签<br>
因为kubeadm部署时会找k8s.gcr.io标签的镜像，因此需要将上一步pull的镜像打上k8s.gcr.io标签。</li>
</ol>
<pre><code>docker tag registry.cn-hangzhou.aliyuncs.com/wyc_google_containers/kube-apiserver:$KUBE_VERSION  k8s.gcr.io/kube-proxy:$KUBE_VERSION
docker tag registry.cn-hangzhou.aliyuncs.com/wyc_google_containers/kube-apiserver:$KUBE_VERSION k8s.gcr.io/kube-controller-manager:$KUBE_VERSION
docker tag registry.cn-hangzhou.aliyuncs.com/wyc_google_containers/kube-apiserver:$KUBE_VERSION k8s.gcr.io/kube-apiserver:$KUBE_VERSION
docker tag registry.cn-hangzhou.aliyuncs.com/wyc_google_containers/kube-apiserver:$KUBE_VERSION k8s.gcr.io/kube-scheduler:$KUBE_VERSION
docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/pause:$PAUSE_VERSION k8s.gcr.io/pause:$PAUSE_VERSION
docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:$CORE_DNS_VERSION k8s.gcr.io/coredns:$CORE_DNS_VERSION
docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:$ETCD_VERSION k8s.gcr.io/etcd:$ETCD_VERSION
</code></pre>
<ol start="3">
<li>移除从阿里云pull下来的镜像</li>
</ol>
<pre><code>docker rmi registry.cn-hangzhou.aliyuncs.com/wyc_google_containers/kube-apiserver:$KUBE_VERSION
docker rmi registry.cn-hangzhou.aliyuncs.com/wyc_google_containers/kube-controller-manager:$KUBE_VERSION
docker rmi registry.cn-hangzhou.aliyuncs.com/wyc_google_containers/kube-scheduler:$KUBE_VERSION
docker rmi registry.cn-hangzhou.aliyuncs.com/wyc_google_containers/kube-proxy:$KUBE_VERSION
docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/pause:$PAUSE_VERSION
docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:$CORE_DNS_VERSION
docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:$ETCD_VERSION
</code></pre>
<h2 id="开始部署">开始部署</h2>
<pre><code>kubeadm init --apiserver-advertise-address=你的本机IP --pod-network-cidr=10.244.0.0/16  --kubernetes-version=v1.18.8
#执行后的输出
...
...
kubeadm join 192.168.127.132:6443 --token 4pwz11.1m0u1k3ak3ibgx08 \
    --discovery-token-ca-cert-hash sha256:671404c4f80afe5d06d8eefcd5acc6049c4d84f1ebf1091b09bc180ea44e79b7
</code></pre>
<p>将输出内容中的<code>kubeadm join ...</code>单独保存出来，这是其他节点加入主节点的信息。</p>
<h2 id="赋予当前用户使用kubectl的权限">赋予当前用户使用kubectl的权限</h2>
<pre><code>mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<h2 id="安装网络组件flannel">安装网络组件flannel</h2>
<h3 id="准备工作-2">准备工作</h3>
<p>由于种种原因，无法直接pull到网络组件flannel的docker镜像，因此需单独下载。<br>
https://github.com/coreos/flannel/releases/download/v0.12.0/flanneld-v0.12.0-amd64.docker<br>
下载后放进<code>~/k8s</code>，执行命令：</p>
<pre><code>cd ~/k8s
docker load &lt; flanneld-v0.12.0-amd64.docker
</code></pre>
<h3 id="开始安装">开始安装</h3>
<pre><code>wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
kubectl apply -f kube-flannel.yml
</code></pre>
<h2 id="检查部署情况">检查部署情况</h2>
<pre><code>kubectl get nodes
</code></pre>
<p><img src="https://tomhht.github.io/post-images/1598781753839.png" alt="节点运行情况" loading="lazy">     <br /></p>
<pre><code>kubectl get pods -A
</code></pre>
<p><img src="https://tomhht.github.io/post-images/1598781791291.png" alt="Pods运行情况" loading="lazy"><br>
通过<code>docker container ls</code>也可以看到pods里的容器运行情况。</p>
<p>以上为control node控制节点的部署全流程。</p>
<hr>
<h1 id="worker-node工作节点加入集群">worker node工作节点加入集群</h1>
<h2 id="安装kubeadm-kubelet和kubectl-2">安装kubeadm, kubelet和kubectl</h2>
<p>在worker node上，按照上面<strong>安装前的准备工作</strong>和<strong>安装kubeadm, kubelet和kubectl</strong>操作。</p>
<h2 id="载入control-node上pull好的镜像">载入control  node上pull好的镜像</h2>
<ol>
<li>在control node上，备份出全套docker镜像（含kubeadm所需镜像+网络组件flannel镜像）：</li>
</ol>
<pre><code>cd ~/k8s
docker save k8s.gcr.io/kube-proxy:v1.18.8 \
k8s.gcr.io/kube-apiserver:v1.18.8 \
k8s.gcr.io/kube-controller-manager:v1.18.8 \
k8s.gcr.io/kube-scheduler:v1.18.8 \
k8s.gcr.io/pause:3.2 \
k8s.gcr.io/coredns:1.6.7 \
k8s.gcr.io/etcd:3.4.3-0 \
quay.io/coreos/flannel:v0.12.0-amd64 &gt; k8s-imagesV1.18.8-flannelV0.12.0.tar
</code></pre>
<blockquote>
<p>之前踩坑，偷懒用IMAGE ID做的备份，结果载入以后name和tag全都是none，还得打name和tag上去，无比繁琐- _ -||</p>
</blockquote>
<ol start="2">
<li>scp上面的备份文件到各个worker node的<code>~/k8s</code>文件夹里</li>
<li>在worker node上载入备份文件：</li>
</ol>
<pre><code>cd ~/k8s
docker load &lt; k8s-imagesV1.18.8-flannelV0.12.0.tar
</code></pre>
<h2 id="加入集群">加入集群</h2>
<p>执行之前在control node上单独保存出来的<code>kubeadm join...</code>，类似于：</p>
<pre><code>kubeadm join 192.168.127.132:6443 --token rddtz5.mz2v4ee96177eay5     --discovery-token-ca-cert-hash sha256:671404c4f80afe5d06d8eefcd5acc6049c4d84f1ebf1091b09bc180ea44e79b7
</code></pre>
<p>如果join指令没记录下来，或者集群创建已经超过24小时了，那么需要重新生成join指令。在<strong>control node</strong>上执行：</p>
<pre><code>kubeadm token create --print-join-command
</code></pre>
<p>复制输出的内容并在<strong>worker node</strong>上执行即可加入。</p>
<hr>
<h1 id="检查部署结果">检查部署结果</h1>
<p>在control node上执行：</p>
<pre><code>kubectl get nodes -o wide
</code></pre>
<p><img src="https://tomhht.github.io/post-images/1598863291668.png" alt="集群节点信息" loading="lazy"> <br /></p>
<pre><code>kubectl get pods -A -o wide
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tomhht.github.io/post-images/1598863358214.png" alt="集群pods信息" loading="lazy"></figure>
<hr>
<p>参考链接：<br>
<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/</a><br>
<a href="https://www.cnblogs.com/hellxz/p/use-kubeadm-init-kubernetes-cluster.html">https://www.cnblogs.com/hellxz/p/use-kubeadm-init-kubernetes-cluster.html</a><br>
<a href="https://blog.csdn.net/LeonardoYasuo/article/details/101483438">https://blog.csdn.net/LeonardoYasuo/article/details/101483438</a><br>
<a href="https://www.cnblogs.com/yinzhengjie/p/12258215.html">https://www.cnblogs.com/yinzhengjie/p/12258215.html</a></p>
]]></content>
    </entry>
</feed>